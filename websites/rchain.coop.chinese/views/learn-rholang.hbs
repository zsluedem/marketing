<div id="sideNav" class="">
    <div id="close">&lt; &lt; &lt;</div>
    <div>
        <h6>发送、接收以及其他原理</h6>
        <ul>
            <li><a id="sending" class="scroll" href="javascript:void(0)">发送与标准输出</a></li>
            <li><a id="receiving" class="scroll" href="javascript:void(0)">接收</a></li>
            <li><a id="telephone" class="scroll" href="javascript:void(0)">电话、命名与进程</a></li>
            <li><a id="sendAndPeek" class="scroll" href="javascript:void(0)">持续发送与峰值</a></li>
            <li><a id="joinOperator" class="scroll" href="javascript:void(0)">"求并"运算符</a></li>
        </ul>
        <h6>Name Privacy</h6>
        <ul>
            <li><a id="unforgeable" class="scroll" href="javascript:void(0)">Unforgeable Names and Acks</a></li>
            <li><a id="bundles" class="scroll" href="javascript:void(0)">Bundles</a></li>
            <li><a id="stateChannels" class="scroll" href="javascript:void(0)">State Channels</a></li>
        </ul>
    </div>
</div>
<div id="tab">Contents</div>

<div class="section" id="toContentsSection">

    <div class="lesson" id="fundamentals">
        <div class="card" id="intro">
            <h6>教程 / 学习Rho语言</h6>
            <h2>开始学习Rho语言</h2>
            <p>通过例子和实验来学习rho语言。下面的例子和练习都很值得去运行、阅读、修改完善。更改任何你感到好奇的地方，能够收获最好的学习效果。该教程包含了rho语言最常见以及最重要的特性，足以让开发者快速入门。</p>
        </div>

        <div class="card" id="sendingSection">
            <h1 id="sending-and-standard-out">发送与标准输出(stdout)</h1>
            <h2 id="say-hello">说声Hello</h2>
            <p class="imgWrapper"><img src="/assets/helloWorld.png" alt="&quot;Person waiving hello&quot;"></p>
            <p>编程界有一个存在已久的传统——你应该在你的第一个程序写下"Hello World"。下面是一个在屏幕上输出这段信息的最简单例子。</p>

            <pre class="rholang-file">new stdout('rho:io:stdout') in {
                stdout!("Hello World!")}</pre>

            <h3 id="exercise">练习</h3>
            <p>请让程序输出"Rholang rocks!" 而不是 "Hello World".</p>
            <h3 id="exercise">练习</h3>
            <p>尝试将"stdout"其他语句。会得到什么结果？</p>
            <p></p>
            <ul>
                <li>尝试一下这个有趣的通道名称 <pre><code>@&quot;someChannel&quot;</code></pre>.</li>
                <li>这里可以比较随意。请让程序在屏幕上输出 "Sup World"。</li>
            </ul>
            <h2 id="wth-is-stdout-">标准输出(stdout)到底是啥</h2>
            <p class="imgWrapper"><img src="/assets/mailbox.png" alt="Channels are like mailboxes for sending messages"></p>
            <p>rho语言的核心是通道通信. 通道是你可以用来发送和接收消息的通信线路。你可以使用<code>!</code> 字符来在通道中发送消息.</p>
            <p class="imgWrapper"><img src="/assets/sendSyntax.png" alt="Redo this diagram!"></p>
            <p><code>stdout</code> 是一个特殊的通道，用于将文本发送至"标准输出",通常指你的电脑屏幕。正因为它的特殊，我们不得不将它写在代码的第一行。</p>
            <h2 id="using-other-channels">使用其他通道</h2>
            <p class="imgWrapper"><img src="/assets/mailboxes.png" alt="Sent messages wait to be received here in &quot;message purgatory&quot;... JK, it&#39;s called the &quot;tuplespace&quot;"></p>
            <p>实际上你可以在很多通道中发送消息，而非只有<code>stdout</code>. 但不像<code>stdout</code> 他们不会在屏幕上显示.</p>

            <pre class="rholang-file">&commat;"RandoChannel"!("This won't be on the screen")</pre>

            <p>那么，在其他通道中的消息将被发送至哪里？哪里都不会去！无论如何都不会。这些消息会继续待在通道内，等待某个程序去消费它们。我们将在下一课程中学习如何消费这些消息。同时，消息滞留所在的地方，我们称为 "元组空间"</p>
            <p>还记得你曾经在之前尝试写过下面这段代码么？请再一次尝试，并确保你的消息停留在元组空间中。</p>
            <p class="imgWrapper"><img src="/assets/tupleSpace.png" alt="You should find something like this highlighted text in your tuplespace."></p>
            <h2 id="doing-two-things-at-once">同时做两件事</h2>
            <p class="imgWrapper"><img src="/assets/cooking.png" alt="Rather than following an ordered list, all ingredients are added concurrently.  Looks delicions"></p>
            <p>在rho语言中，我们不会告诉计算机做完一件事，再到另一件。相反，我们会告诉它需要做的所有事情，然后"并行地"执行它们，或者一次性执行。</p>

            <pre class="rholang-file">new stdout(`rho:io:stdout`) in {
  stdout!("I'm on the screen")
  |
  &commat;"chan1"!("I'm in the tupplespace")
}
</pre>

            <p><code>|</code> 的发音是 &quot;parallel&quot, 可简称为 &quot;par&quot;.</p>
            <h3 id="exercise">锻炼</h3>
            <p>向"pizza shop"通道发送消息"1 large peperoni please" </p>
            <h3 id="exercise">锻炼</h3>
            <p>向"Mom's Phone"通道发送"Hi Mom"</p>
            <h3 id="exercise">锻炼</h3>
            <p>打印两个消息，"Rick"和 "Morty"</p>
            <h2 id="quiz">小测试</h2>
            <p><code>stdout!(&quot;Programming!&quot;)</code> 将在屏幕上打印什么？</p>
            <ul class="quiz">
                <li><input type="radio" name="quiz1" value="correct" id="Programming!" class="quiz"> Programming!</li>
                <li><input type="radio" name="quiz1" value="incorrect" id="stdout!" class="quiz"> stdout!</li>
                <li><input type="radio" name="quiz1" value="incorrect" id="Nothing" class="quiz"> Nothing</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz1Correct">正确!</p>
                <p class="incorrect" id="quiz1incorrect">错误。请再试一次。</p>
            </div>
            <p> <code>@&quot;what&quot;!(&quot;Up&quot;)</code>在什么通道上发送消息？</p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz2" class="quiz"> <code>@&quot;Up&quot;</code></li>
                <li><input value="correct" type="radio" name="quiz2" class="quiz"> <code>@&quot;what&quot;</code></li>
                <li><input value="incorrect" type="radio" name="quiz2" class="quiz"> <code>what</code></li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz2Correct">正确!</p>
                <p class="incorrect" id="quiz2incorrect">错误。请再试一次。</p>
            </div>
            <p>rho语言会先执行哪一条语句？</p>
            <pre class="inline-code">@"stdout"!("Dogs")
|
@"stdout"!("Cats")</pre>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz3" class="quiz"> 打印 &quot;Dogs&quot;</li>
                <li><input value="incorrect" type="radio" name="quiz3" class="quiz"> 打印 &quot;Cats&quot;</li>
                <li><input value="correct" type="radio" name="quiz3" class="quiz"> 都不. 它们是并行的</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz3Correct">正确!</p>
                <p class="incorrect" id="quiz3incorrect">错误。请再试一次。</p>
            </div>
            <p>PS. There is also a special channel called <code>stderr</code>. Check out what happens when you send to it.</p>
            <p>PS. 有一个特殊的通道 <code>stderr</code>. 请尝试一下看看往这个通道发送消息，会发生什么？</p>
            <p><a href="https://en.wikipedia.org/wiki/Standard_streams">有什么区别?</a></p>


        </div>


        <div class="card" id="receivingSection">
            <h1 id="receiving">接收</h1>
            <h2 id="check-for-messages">消息检查</h2>
            <p class="imgWrapper"><img src="/assets/Keys.png" alt="// Dear future self, keys in freezer because..."></p>
            <p>在上一章我们学习了如何发送消息。现在是时候学习如何接收消息了。常规语法如下：</p>
            <p><code>for(message &lt;- channel){ // Do something here}</code></p>
            <p>顺便提一下， <code>//</code> 用于书写注释。 它们仅仅是为了方便开发者阅读，并不会影响程序的运行。</p>
            <h2 id="comm-events">通信事件</h2>
            <p class="imgWrapper"><img src="/assets/pizza.png" alt="Pizza shop can receive messages on its channel."></p>
            <p>下面的代码使用披萨店的通道发送了一个消息，pizza店收到了它。pizza店通过将消息打印至标准输出来表明其已收到。</p>
            <p><a href="pizzaOrder.rho">pizza订单</a></p>
            <h3 id="exercise">练习</h3>
            <p>将上述消息发送至一个不同的通道，如<code>@&quot;coffeShop&quot;</code>. 消息会被接收端打印出来吗? 还是留在了元组空间里？</p>
            <p class="imgWrapper"><img src="/assets/coffee.png" alt="Let&#39;s hit up the coffee shop."></p>
            <h3 id="exercise">练习</h3>
            <p>记住，在rholang中，任何事情都是并行地而非按顺序地发生。如果我们先接收信息，披萨店的代码仍然有效。</p>
            <h2 id="tuplespace-pollution">元组空间污染</h2>
            <!-- TODO I really wasn't sure where to put this part -->
            <p>如果你遇到了旧数据滞留并在随后出现的困扰，你需要清空你的元组空间。最简单的方式是删除你的数据目录<code>.rnode</code></p>
            <!-- TODO I should write a script for this -->

            <p>使用上述方法清空元组空间已经过时了。一个更好的方法是防止它首先被污染。我们可以通过修改最上面的new代码段来实现。</p>
            <p>旧的方案</p>
            <pre class="inline-code">new stdout(`rho:io:stdout`) in {
  @"world"!("Welcome to RChain")
}</pre>
            <p>尝试下面新的方案</p>
            <pre class="inline-code">new world, stdout(`rho:io:stdout`) in {
  world!("Welcome to RChain") // 不会再有@或者" "
}</pre>
            <p>我们将在不可伪造命名的课程中讲解它的原理。现在你不需要每次都重置通道。</p>
            <h2 id="receiving-before-sending">发送前接收</h2>
            <p class="imgWrapper"><img src="/assets/lookingForMessages.png" alt="Rather than the message appearing first, then someone receiving it, Greg is trying to receive first. Hopefully someone will send him a message so he can have a comm event."></p>
            <p>当发送和接收同时存在于通道时，这被称为通信事件，或简称为"comm event"。</p>
            <p>不像普通邮件那样必须被发送，对方才能被接收，在rholang中，上述两个事件可以以某个顺序或者同时发生。这类似于可以先接收消息，再发送它。每当发送和接收共存时，就会触发通信事件。</p>
            <h2 id="contracts">合约</h2>
            <p class="imgWrapper"><img src="/assets/pizzaBurning.png" alt="The poor chef is too busy making sure he can receive orders to take care of his pizza."></p>
            <p>我们的披萨店例子很好地说明了通信事件，但期望每次有新的订单时，披萨店都能自动发出一个新的接收来消耗它们，这并不现实。</p>
            <p>Luckily it&#39;s possible to deploy code once, and have it run <em>every</em> time it receives a message. This kind of thing is called a &quot;smart contract&quot;. Let&#39;s look at some code for a coffee shop that is much superior to the pizza shop.</p>
            <p>幸运地是，只部署一次代码，<em>每次</em>接收到它的消息时都执行一次，是可能的。这类代码称为“智能合约”。让我们看一个比披萨店更高级的，咖啡店的相似例子</p>

            <pre class="rholang-file">new stdout(`rho:io:stdout`) in {
  contract &commat;"coffeeShop"(order) = {
    stdout!("Coffee Order Received")
  }
  |
  &commat;"coffeeShop"!("one hot chocolate")
  |
  &commat;"coffeeShop"!("two large cappuccinos please")
}
</pre>

            <h3 id="exercise">练习</h3>
            <p>在咖啡店点第二杯饮料</p>
            <h3 id="exercise">练习</h3>
            <p>更改确认消息</p>
            <p>一般来说，下列哪一个会第一个到达</p>
            <ul class="quiz">
                <li><input  value="incorrect" type="radio" name="quiz4" class="quiz"> 发送，因为它与普通邮件的工作原理一样。</li>
                <li><input  value="incorrect" type="radio" name="quiz4" class="quiz"> 接收，因为以该方式运行的代码更快。</li>
                <li><input  value="correct" type="radio" name="quiz4" class="quiz"> 发送或接收都可以最先到达，或者同时。</li>
                <li><input  value="incorrect" type="radio" name="quiz4" class="quiz"> 接收，因为rohlang是并行的。</li>
                <li><input  value="incorrect" type="radio" name="quiz4" class="quiz"> 都不。直接触发通信事件(comm event)。</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz4Correct">正确!</p>
                <p class="incorrect" id="quiz4incorrect">错误。</p>
            </div>
            <h3 id="exercise">练习</h3>
            <p>通道被命名为 <code>@&quot;coffeeShop&quot;</code>。将它更名为你所选择的特定咖啡店的名称。然后，使用我们最近学到的 <code>new</code> 来修改代码 </p>
            <h2 id="persistent-for">持久性</h2>
            <p>There are actually two different styles of syntax in rholang to achieve this persistent behavior. We just learned about <code>contract</code>. The following snippets are equivalent.</p>
            <p>实际上，在rholang中有两种不同的语法。我们只学习<code>contract</code>。下面的代码片段是等价的。</p>
            <pre class="inline-code">contract @"coffeeShop"(order) = {</pre><br>
            <pre class="inline-code">for(order &lt;= @"coffeeShop") {</pre>
            <p>注意，上述代码与正常的<code>for</code> 不同，因为它使用了双箭头 <code>&lt;=</code> 而不是 <code>&lt;-</code>. 当我们开始讨论区块链时，持久性与合约的唯一区别就浮出水面了。现在你可以将它们当做同一件事。</p>
            <h3 id="exercise">练习</h3>
            <p>披萨店可以像咖啡店那样使用一个合约。让我们来使用持久性而非合约来书写。尝试通过scratch书写完整的代码，这样你可以更好地记住语法。</p>
            <!-- The solution is in persistentPizzaShop.rho
[persistentPizzaShop.rho](persistentPizzaShop.rho) -->


            <p>下面哪一项是其他两项不同的？</p>
            <ul class="quiz">
                <li><input  value="correct" type="radio" name="quiz5" class="quiz"> <code>for (a &lt;- b){}</code></li>
                <li><input value="incorrect" type="radio" name="quiz5" class="quiz"> <code>contract b(a) = {}</code></li>
                <li><input value="incorrect" type="radio" name="quiz5" class="quiz"> <code>for (a &lt;= b){}</code></li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz5Correct">正确!</p>
                <p class="incorrect" id="quiz5incorrect">错误. 请重试.</p>
            </div>
            <p>哪一个发送语句会在执行<code>for (message &lt;- @&quot;grandmasSnapChat&quot;){0}</code>后产生一个通信事件 ?</p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz6" class="quiz"> <code>grandmasSnapChat!(&quot;Hi Grandma&quot;)</code></li>
                <li><input value="correct"  type="radio" name="quiz6" class="quiz"> <code>@&quot;grandmasSnapChat&quot;!(&quot;Glad you&#39;re snapping Grandma&quot;)</code></li>
                <li><input value="incorrect" type="radio" name="quiz6" class="quiz"> <code>for(&quot;Here&#39;s a snap for you g&#39;ma&quot; &lt;- @&quot;grandmasSnapChat&quot;)</code></li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz6Correct">正确!</p>
                <p class="incorrect" id="quiz6incorrect">错误. 请重新尝试。</p>
            </div>

        </div>

        <div class="card" id="telephoneSection">
            <h1 id="telephone-names-and-processes">传音筒、命名和进程</h1>
            <h2 id="message-relaying">消息传递</h2>
            <p class="imgWrapper"><img src="/assets/telephone.png" alt="The game of telephone is perfect to simulate message forwarding in rholang."></p>
            <p>在前面的章节，我们学习了如何向祖母或披萨店发送消息。但是至今所有的接收方都通过将消息打印至标准输出，来告知已经接收到了。</p>
            <p>现在让我们做一些更有意思的事情——类似孩子们的传话游戏那样传递消息</p>

            <pre class="rholang-file"><code>new stdout(`rho:io:stdout`) in {
  // 通过发送消息给Alice来开启游戏
  @"Alice"!("How to program: Change stuff and see what happens.")
  |

  // 并行地，Alice监听消息
  for (message &lt;- @"Alice") {

    // 当她接收到消息时，她会传递给Bob
    @"Bob"!(*message)
  }
  |

  // 并行地，Bob监听消息
  for (message &lt;- @"Bob") {
    // Bob是最后一名玩家，所以他将宣布消息
    stdout!(*message)
  }
}
</code></pre>

            <p>正如消息所言，通过实验你收获得最多。因此，请你确保按照合适的方式来更改它。</p>
            <h3 id="exercise">练习</h3>
            <p>传话游戏很有趣，但有更多玩家参与会更好。请添加第三位明教Charlie的玩家。bob将发送消息给Charlie，而不是简单打印至<code>stdout</code>。然后Charlie将它打印至屏幕上。多多益善!
            </p>
            <p class="imgWrapper"><img src="/assets/telephoneChangedMessage.png"
                                       alt="The message never seems to get there correctly. I blame Bob."></p>
            <h3 id="exercise">练习</h3>
            <p>如果你曾经玩过电话，你应该知道，消息极少能被完整地传递。Bob决定通过传递一条错误的消息来混淆它。改写程序，使得Bob无论收到什么，都能传递不同的消息。</p>
            <h2 id="wth-is-that-"><code>*</code>这到底是啥？</h2>
            <p class="imgWrapper"><img src="/assets/inverse.png" alt="Opposites attract"></p>
            <p>你注意到 <code>@&quot;Bob&quot;!(*message)</code>中的<code>*</code>? 在rho语言中有两种类型，
                &quot;names&quot; 和 &quot;processes&quot;. 同样也有可以在两者之间互相转化的方法。</p>
            <!-- TODO: Maybe an illustration of arrows labeled * and @ would be better here? -->

            <p>"进程"是rho语言中任何一个代码片段，例如我们的传话筒游戏，或者是披萨店订单程序。进程可以是上百行的大程序，也可以只有几行。它们甚至可以是用于表示值的微小代码片段。</p>
            <ul>
                <li><code>stdout!(&quot;Sup Rholang?&quot;)</code> 一个常见的发送操作。</li>
                <li><code>0</code> 最小的进程。如字面意思，它不做任何事。</li>
                <li><code>for(msg &lt;- @&quot;phone&quot;){0}</code> 一个常见的接收操作，在消息到达时它不会做任何事。</li>
                <li><code>&quot;Hello World&quot;</code> 另一个不做任何事请的小进程。被称为"基础术语"。</li>
            </ul>
            <p>名称可以被用于赋名通道以发送消息。在大多数编程语言中，名称是完全独立的，它们本身就存在。但是在rho语言中，名称来自"引用进程"，即将<code>@</code>标签放在进程之前。</p>
            <ul>
                <li><code>@&quot;Hello World&quot;</code> 通过引用基础术语"Hello World"来创建</li>
                <li><code>@0</code> 最小的名称。通过引用最小的进程来创建。</li>
                <li><code>@(@&quot;Alice&quot;!(&quot;I like rholang, pass it on.&quot;))</code> 通过引用来自传话筒游戏的进程来创建。</li>
            </ul>
            <h2 id="so-what-is-all-about-">关于<code>*</code>的一切</h2>
            <p class="imgWrapper"><img src="/assets/myNameIs.png"
                                       alt="What kind of name is that!? Did your parents just name you after some computer code?">
            </p>

            <p>通过用<code>@</code>符号来引用它们，我们可以将进程打包以创建一些名称。我们也可以通过使用<code>*</code>符号来解引用，从而将名称转变为进程。</p>
            <p>
                在rho语言中，我们需要记住的是<strong>发送进程和接收名称</strong>。这很重要，因此我再次强调。你总是<strong>发送一个进程</strong>，在另一端<strong>接收一个名称</strong>
            </p>
            <p>Aice通过<code>for(message &lt;- @&quot;Alice&quot;)</code>接收我们的消息，所以，
                <code>message</code> 变成了一个名称. 当她之后发送给Bob时，她不得不发送进程，所以她借助语句<code>@"Bob"!(*message)</code>使用<code>*</code>将<code>message</code>转变回一个进程。
            </p>
            <h2 id="quiz">小测验</h2>
            <p>我们发送了什么？</p>
            <ul class="quiz">
                <li><input value="correct" type="radio" name="quiz7" class="quiz"> 进程</li>
                <li><input value="incorrect" type="radio" name="quiz7" class="quiz"> 名称</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz7Correct">正确!</p>
                <p class="incorrect" id="quiz7incorrect">错误. 请重试.</p>
            </div>
            <p>我们接收什么？</p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz8" class="quiz"> 进程</li>
                <li><input value="correct" type="radio" name="quiz8" class="quiz"> 名称</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz8Correct">正确!</p>
                <p class="incorrect" id="quiz8incorrect">错误. 请重试.</p>
            </div>
            <p><code>@&quot;registration&quot;</code>是什么</p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz9" class="quiz"> 进程</li>
                <li><input value="correct" type="radio" name="quiz9" class="quiz"> 名称</li>
                <li><input value="incorrect" type="radio" name="quiz9" class="quiz"> 非法语法</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz9Correct">正确!</p>
                <p class="incorrect" id="quiz9incorrect">错误. 请重试.</p>
            </div>
            <p><code>0</code>是什么?</p>
            <ul class="quiz">
                <li><input value="correct" type="radio" name="quiz10" class="quiz"> 进程</li>
                <li><input value="incorrect" type="radio" name="quiz10" class="quiz"> 名称</li>
                <li><input value="incorrect" type="radio" name="quiz10" class="quiz"> 非法语法</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz10Correct">正确!</p>
                <p class="incorrect" id="quiz10incorrect">错误. 请重试.</p>
            </div>
            <p><code>@0</code>是什么?</p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz11" class="quiz"> 进程</li>
                <li><input value="correct" type="radio" name="quiz11" class="quiz"> 名称</li>
                <li><input value="incorrect" type="radio" name="quiz11" class="quiz"> 非法语法</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz11Correct">正确!</p>
                <p class="incorrect" id="quiz11incorrect">错误. 请重试.</p>
            </div>
            <p><code>@@0</code>是什么?</p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz12" class="quiz"> 进程</li>
                <li><input value="incorrect" type="radio" name="quiz12" class="quiz"> 名称</li>
                <li><input value="correct" type="radio" name="quiz12" class="quiz"> 非法语法</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz12Correct">正确!</p>
                <p class="incorrect" id="quiz12incorrect">错误. 请重试.</p>
            </div>
            <p><code>*importantData</code> 是一个进程，那么 <code>importantData</code>是什么?</p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz13" class="quiz"> 进程</li>
                <li><input value="correct" type="radio" name="quiz13" class="quiz"> 名称</li>
                <li><input value="incorrect" type="radio" name="quiz13" class="quiz"> 非法语法</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz13Correct">正确!</p>
                <p class="incorrect" id="quiz13incorrect">错误. 请重试.</p>
            </div>
            <p> 下面哪一个与<code>&quot;BobsPhone&quot;</code>等价?</p>
            <ul class="quiz">
                <li><input value="correct" type="radio" name="quiz14" class="quiz"> <code>*@&quot;BobsPhone&quot;</code>
                </li>
                <li><input value="incorrect" type="radio" name="quiz14" class="quiz">
                    <code>@&quot;BobsPhone&quot;</code></li>
                <li><input value="incorrect" type="radio" name="quiz14" class="quiz">
                    <code>*&quot;BobsPhone&quot;</code></li>
                <li><input value="incorrect" type="radio" name="quiz14" class="quiz"> <code>@*BobsPhone</code></li>
                <li><input value="incorrect" type="radio" name="quiz14" class="quiz"> <code>stdout!(&quot;BobsPhone&quot;)</code>
                </li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz14Correct">正确!</p>
                <p class="incorrect" id="quiz14incorrect">错误. 请重试.</p>
            </div>
            <h3 id="exercise">练习</h3>
            <p class="imgWrapper"><img src="/assets/telephoneFork.png" alt="This telephone game has a fork"></p>
            <p>不像之前的线性传话游戏那样，每个玩家将信息传递给下一位，我么来为游戏添加一个分支。现在，Bob与先前一样将发送消息给Charlie，但同时也会发送给Elise。</p>
            <p>每个分支的长度由你定，但在每个分支的最后都得将消息打印至标准输出。</p>

        </div>


        <div class="card" id="sendAndPeekSection">
            <h1 id="persistent-sends-and-peek">持续发送与窥探</h1>
            <h2 id="why-send-repeatedly-">为什么要重复发送？</h2>
            <p class="imgWrapper"><img src="/assets/broadcasting.png"
                                       alt="This radio navigation aid helps airplanes navigate by broadcasting the same message over and over">
            </p>
            <p>我们的披萨和咖啡店都乐于在同一复用通道中接收消息。我们使用一个持续的 <code>for (msg &lt;= chan){...}</code>或者一个合约<code>contract
                chan(msg){...}</code>来达成这一目的。</p>
            <p>空中交通管制塔楼可能会乐于做刚好相反的事——不停地发送相同的消息。塔楼中的控制者希望记录同时包含天气和跑道信息的消息，并且提供给所有需要的飞行员。类似披萨店，
                他们很繁忙，不会费力地在每次飞行员需要时都不停地发送信息。
            </p>
            <h2 id="persistent-send-syntax">持续发送的语法</h2>
            <p>控制塔需要在代码上做较小的调整，以使得发送操作能够持续。他们会使用<code>!!</code>而非单个<code>!</code>。</p>
            <pre class="rholang-file">// ATC sends the info
@"airportInfo"!!("No wind; Runway 11")
|
// 飞行员接收信息
for (info &lt;- @"airportInfo") {
  0 // 飞行员仅仅监听，不做任何其他事情
}
</pre>

            <p>请自行确认一下，原先的发送是否仍然在元组空间内。</p>
            <h3 id="exercise">练习</h3>
            <p>注意上述代码，第二名飞行员同样能够接收到信息。发送仍在持续。</p>
            <p>对了，你注意到了吗？当我们实际上并不使用<code>stdout</code>时，我们不需要<code>new stdout(...) in {}</code></p>
            <p><code>for (x &lt;- y) {0} | y!!(0)</code>中有多少次通信事件发生？</p>
            <ul class="quiz">
                <li><input value="correct"  type="radio" name="quiz15" class="quiz"> <code>1</code></li>
                <li><input value="incorrect" type="radio" name="quiz15" class="quiz"> <code>很多</code></li>
                <li><input value="incorrect" type="radio" name="quiz15" class="quiz"> <code>0</code></li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz15Correct">正确!</p>
                <p class="incorrect" id="quiz15incorrect">错误. 请重试.</p>
            </div>
            <h2 id="double-checking-a-message">二次检查消息</h2>
            <p>正如我们刚才展示的，持续性发送和接收非常有用。但是，普通的发送和接收也同样足够好了。设想这样的场景：我将一个字母发送给祖母，她接收到了这个消息。</p>
            <pre class="rholang-file">new grandma, stdout(`rho:io:stdout`) in {
  // 我发送一条消息
  grandma!("Meet at the mall at 4:00")
  |
  // 祖母接收到它
  for (msg &lt;- grandma){
    stdout!("I got your message")
  }
}
</pre>

            <p>现在我们设想：我想要二次检查我是否给她发送了正确的时间。我可以简单地消费这条消息，但这样一来她就没法读取这个消息了。</p>
            <h3 id="exercise">练习</h3>
            <p>依据你所知道的，你可以通过消费这个消息，自行检查它，再将它发送回旧的通道，以达到我们的目的。</p>
            <p>请自行尝试上面的方案。答案已列在下面。</p>
            <p><code>for (x &lt;= y) {0} | y!!(0)</code>会产生多少个通信事件？</p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz16" class="quiz"> <code>1</code></li>
                <li><input value="correct"  type="radio" name="quiz16" class="quiz"> <code>很多</code></li>
                <li><input value="incorrect" type="radio" name="quiz16" class="quiz"> <code>0</code></li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz16Correct">正确!</p>
                <p class="incorrect" id="quiz16incorrect">错误. 请重试.</p>
            </div>
            <h2 id="answer-to-exercise">答案</h2>
            <p>

            </p>
            <pre class="rholang-file">new grandma, stdout(`rho:io:stdout`) in {
  // 我发送一条消息
  grandma!("Meet at the mall at 4:00")
  |
  // 我二次检查这条消息
  for (msg &lt;- grandma){
    stdout!("Double checking the message")
    |
    // 将一个副本发送会祖母
    grandma!(*msg)
  }
  |
  // 祖母接收到消息
  for (msg &lt;- grandma){
    stdout!("I got your message")
  }
}
</pre>
            <h2 id="peek-syntax">窥探语法</h2>
            <p class="imgWrapper"><img src="/assets/letterPeak.png" alt="Maybe I&#39;ll just peak at Grandma&#39;s letter through the envelope."></p>
            <p>Rho语言最终为上述需求提供了一个特殊的语法。目前我们还不能使用它，但是我会展示给你看。我们将使用<code>&lt;!</code>操作符来"窥探"一个通道内的消息。</p>
            <pre class="rholang-file">// 提示: Peek目前尚未实现

// 我发送消息
&commat;"grandma"!("Meet at the mall at 4:00")
|
// 我二次检查这条消息
for (msg &lt;! &commat;"grandma"){
  0 // 请你想做的任何事情来检查时间
    // 消息在通道中仍然安全
}
|
// 祖母接收到消息
for (msg &lt;- &commat;"grandma"){
  &commat;"stdout"!{"I got your message"}
}
</pre>

            <p>如果你使用过电子表格宏，或者电子表格，你应该对如何在不消费数据的情况下访问它感到非常熟悉。把它想象成</p>
            <p>下列哪一个语法是用于窥探一个消息的？</p>
            <ul class="quiz">
                <li><input value="correct"   type="radio" name="quiz17" class="quiz"> <code>for (x &lt;! y){...}</code></li>
                <li><input value="incorrect"  type="radio" name="quiz17" class="quiz"> <code>for (x &lt;= y){...}</code></li>
                <li><input value="incorrect"  type="radio" name="quiz17" class="quiz"> <code>x!!(y)</code></li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz17Correct">正确!</p>
                <p class="incorrect" id="quiz17incorrect">错误. 请重试.</p>
            </div>
            <p>How many comms happen in <code>for (x &lt;! y) {0} | y!!(0)</code></p>
            <p><code>for (x &lt;! y) {0} | y!!(0)</code>会产生多少个通信事件</p>
            <ul class="quiz">
                <li><input value="correct"   type="radio" name="quiz18" class="quiz"> <code>1</code></li>
                <li><input value="incorrect" type="radio" name="quiz18" class="quiz"> <code>许多</code></li>
                <li><input value="incorrect" type="radio" name="quiz18" class="quiz"> <code>0</code></li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz18Correct">正确!</p>
                <p class="incorrect" id="quiz18incorrect">错误. 请重试.</p>
            </div>

        </div>

        <div class="card" id="joinOperatorSection">
            <h1 id="join-operator">求并运算符</h1>
            <h2 id="multiple-data-sources">多数据源</h2>
            <p class="imgWrapper"><img src="/assets/pushups.png" alt="In general, the winner of this pushup competition can&#39;t be determined until both participants are finished."></p>
            <p>有时候仅当从两个以上不同的数据源获取数据后，才会开始计算。例如，在你得知了你的彩票号码和中奖号码之前，你无法知道你是否赢得大奖。在你知道价格和投标总额之前，你无法对购买决定进行更改。在你赢得俯卧撑比赛之前，你无法知道每个参赛者做了几个俯卧撑</p>
            <p>Rho语言提供了求并运算符，来应对这种情况。使用<code>;</code>符号来执行一次求并操作。</p>
            <pre class="inline-code">for (p1Pushups &lt;- @"player1"; p2Pushups &lt;- @"player2") {
  @"stdout"!("The winner is...")
}</pre>
            <h2 id="rocket-launch">火箭着陆</h2>
            <p>一家空间探索公司想要确保，仅当两个航空工程师，Alice和Bob，都下达了着陆命令后，他们的火箭才会着陆。例如，Bob将通过发送<code>BobLaunch!(&quot;launch&quot;)</code>来下达命令。当两位工程师都下达了命令，那么火箭便可以着陆。</p>
            <h3 id="exercise">练习</h3>
            <p>Consider how this code might be written using the join operator that we just learned discussed.</p>
            <p>思考一下，使用我们刚提到的求并操作符，应该怎么书写代码呢？</p>
            <h2 id="the-wrong-way">一个错误的方式</h2>
            <p>One may have been tempted to solve the rocket problem by first receiving one launch command then the other.</p>
            <p>下面的例子中，其中一人先收到着陆指令，并尝试处理火箭着陆问题，然后再轮到另一个人。</p>
            <pre class="rholang-file">new stdout(`rho:io:stdout`) in {
  // 监听Alice的着陆指令，然后是Bob的
  for (x &lt;- @"AliceLaunch"){
    for (y &lt;- @"BobLaunch"){
      stdout!("Launching the rocket")
    }
  }
  |
  // 当准备就绪，工程师们发送他们的指令
  @"AliceLaunch"!("launch")
  |
  @"BobLaunch"!("launch")
}
</pre>
            <p>问题在于，当Alice批准着陆，而Bob还没有，Alice应该能够更改她的指令，但在此例中她不行。设想一下，如果她突然发觉火箭有一个问题，或者收到了一些不好的消息，想要停止着陆。</p>
            <p class="imgWrapper"><img src="/assets/join.png" alt="No use in grabbing just one set of mail. Might as well wait until the second set"></p>
            <p>当使用求并时，她依然可以更改她的决定，因为<code>for</code>只会在双方的消息都进入通道并准备好后，才会开始消费双方的消息。</p>
            <h2 id="launch-solution">着陆的解决方案</h2>
            <pre class="rholang-file">new stdout(`rho:io:stdout`) in {
  // 同时监听两个着陆指令
  for (x &lt;- @"AliceLaunch"; y &lt;- @"BobLaunch"){
    stdout!("Launching the rocket")
  }
  |
  // 当准备就绪，工程师们发送他们的指令
  @"AliceLaunch"!("launch")
  |
  @"BobLaunch"!("launch")
}
</pre>
            <p>下列哪一段代码是Alice所需，用以撤销着陆命令的？</p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz19" class="quiz"> <code>@&quot;AliceCancel&quot;!(&quot;cancelZ&quot;)</code></li>
                <li><input value="incorrect" type="radio" name="quiz19" class="quiz"> <code>@&quot;AliceLaunch&quot;!(&quot;cancel&quot;)</code></li>
                <li><input value="correct"  type="radio" name="quiz19" class="quiz"> <code>for (x &lt;- @&quot;AliceLaunch&quot;){0}</code></li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz19Correct">正确!</p>
                <p class="incorrect" id="quiz19incorrect">错误. 请重试.</p>
            </div>
            <p>求并的概念起初是在哲学家进餐问题中被提出，并且在这篇简短的rho语言教程中<a href="https://developer.rchain.coop/tutorial/#dining-philosophers-and-deadlock&quot;]">(更详细的解释)</a></p>
            <p>在<code>for (x &lt;- y; a &lt;- b){ 0 }</code>中, 应该优先向哪一个通道发送消息？</p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz20" class="quiz"> y</li>
                <li><input value="incorrect" type="radio" name="quiz20" class="quiz"> b</li>
                <li><input value="correct"  type="radio" name="quiz20" class="quiz"> 无所谓</li>
                <li><input value="incorrect" type="radio" name="quiz20" class="quiz"> 应该同时被发送</li>
            </ul>
             <div class="quizResponse">
                <p class="correct" id="quiz20Correct">正确!</p>
                <p class="incorrect" id="quiz20incorrect">错误. 请重试.</p>
            </div>
            <p>在<code>for (x &lt;- y; a &lt;- b){ 0 }</code>中, 哪一条消息被优先消费？</p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz21" class="quiz"> x</li>
                <li><input value="incorrect" type="radio" name="quiz21" class="quiz"> a</li>
                <li><input value="incorrect" type="radio" name="quiz21" class="quiz"> 无所谓</li>
                <li><input value="correct"  type="radio" name="quiz21" class="quiz"> 会被同时消费</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz21Correct">正确!</p>
                <p class="incorrect" id="quiz21incorrect">错误. 请重试.</p>
            </div>
            <h3 id="exercise">练习</h3>
            <p>有一个比赛，两名选手将各自在分开的通道发送消息。谁第一个发送了消息，谁就输掉比赛，第二个发送消息的人获胜。你的任务是写一段代码告诉我们谁能赢。参赛选手应按如下方式发送消息。</p>
            <p><code>P1!(&quot;Send any message&quot;)</code>
                <code>P2!(&quot;Hope I win&quot;)</code></p>
            <p>耐心竞赛的解决方案。在这一例子中，我们不使用求并运算，因为我们在意哪个选手先行动。希望我没有骗你;)</p>
            <pre class="rholang-file">new stdout(`rho:io:stdout`) in {
  // 使用rnode repl来测试你的代码
  // 以两个不同的顺序发送消息
  // @"P1"!("Send any message")
  // @"P2"!("Hope I win")


  // 选手一获胜
  for (m2 &lt;- @"P2"){
    for (m1 &lt;- @"P1"){
      stdout!("Player one wins!")
    }
  }
  |
  // 选手二获胜
  for (m1 &lt;- @"P1"){
    for (m2 &lt;- @"P2"){
      stdout!("Player two wins!")
    }
  }
}
</pre>
            <p>正如注释所说，你应该用两种不同的顺序来消费它们的消息，以得知谁最终获得胜利。最早实现的方法可能是在REPL中。另一个方案如下所示，让一个玩家去通知另一个玩家何时执行。我们将在下一单元继续探索这一概念。</p>
            <pre class="rholang-file">new P1, P2, signal in {
  // P1发送消息，然后通知正在等待的P2
  P1!("Send any message")
  |
  signal!("Go ahead, I'm done.")
  |
  // 当P2收到信号，他将发送他的消息
  for (_ &lt;- signal){
    P2!("Hope I win")
  }
}
</pre>
            <p>在上面我们写的代码中，为什么可能出现没有人赢得这场耐心比赛？</p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz22" class="quiz"> 因为两名选手可以同时发送消息 </li>
                <li><input value="incorrect" type="radio" name="quiz22" class="quiz"> 选手们在错误的通道发送消息 </li>
                <li><input value="correct"  type="radio" name="quiz22" class="quiz"> 第一个块接收P2，而第二个块接收P1，所以没人能够完成。</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz22Correct">正确!</p>
                <p class="incorrect" id="quiz22incorrect">错误. 请重试.</p>
            </div>
        </div>

        <div class="card" id="unforgeableSection">
            <h1 id="unforgeable-names-and-acks">Unforgeable Names and Acks</h1>
            <h2 id="making-channels-private">Making Channels &quot;Private&quot;</h2>
            <p class="imgWrapper"><img src="/assets/stealing.png" alt="A competing pizza shop steals orders because the channel isn&#39;t secure."></p>
            <p>So far every channel we&#39;ve sent on has been a public name like <code>@&quot;pizzaShop&quot;</code>. Anyone can send a message to this channel (which is good for business) but anyone can receive a message on it too (which is terrible for business). Imagine if competitors could consume pizza orders so that the pizza shop never received them.</p>
            <p>What code would a bad pizza shop have to write to intercept orders?`</p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz23" class="quiz">contract evilPizzaShop(interceptedMessage) = {0}</li>
                <li><input value="incorrect" type="radio" name="quiz23" class="quiz"> <code>@&quot;evilPizzaShop&quot;!(&quot;pizzaShop&quot;)</code></li>
                <li><input value="incorrect" type="radio" name="quiz23" class="quiz"> <code>@&quot;pizzaShop&quot;!(&quot;intercept&quot;)</code></li>
                <li><input value="correct"  type="radio"name="quiz23" class="quiz"> <code>for (interceptedMessage &amp;lt;- @&quot;pizzaShop&quot;){...}</code></li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz23Correct">Correct!</p>
                <p class="incorrect" id="quiz23incorrect">Incorrect. Please try again.</p>
            </div>
            <h2 id="bound-and-free-names">Bound and Free Names</h2>
            <p>We learned how to receive messages with <code>for</code> and <code>contract</code> last time. Both of these constructs &quot;bind&quot; names. For example, order is a bound name within the coffee shop code.</p>
            <pre class="rholang-file">for (order &lt;= @"coffeeShop") {
  @"stdout"!("Coffee Order Received")
}
</pre>
            <p>The same is true when we use contracts.</p>
            <pre class="rholang-file">contract @"coffeeShop"(order) = {
  @"stdout"!("Coffee Order Received")
}
</pre>
            <p>A name is considered bound if it only exists inside a specific process and can&#39;t be accessed from outside. So the name order is bound in the coffee code. On the other hand, any name that can be accessed from elsewhere is a &quot;free&quot; name. <code>@&quot;coffeeShop&quot;</code> is a free name in the above examples.</p>
            <p>State whether <code>x</code> is bound or free in each of the following code snippets.</p>
            <p><code>for (x &amp;lt;- y){0}</code></p>
            <ul class="quiz">
                <li><input value="correct"  type="radio" name="quiz24" class="quiz"> Bound</li>
                <li><input value="incorrect" type="radio" name="quiz24" class="quiz"> Free</li>
                <li><input value="incorrect" type="radio" name="quiz24" class="quiz"> Neither</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz24Correct">Correct!</p>
                <p class="incorrect" id="quiz24incorrect">Incorrect. Please try again.</p>
            </div>
            <p><code>for (y &amp;lt;- x){0}</code></p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz25" class="quiz"> Bound</li>
                <li><input value="correct"  type="radio" name="quiz25" class="quiz"> Free</li>
                <li><input value="incorrect" type="radio" name="quiz25" class="quiz"> Neither</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz25Correct">Correct!</p>
                <p class="incorrect" id="quiz25incorrect">Incorrect. Please try again.</p>
            </div>
            <p><code>new x in { x!(true) }</code></p>
            <ul class="quiz">
                <li><input value="correct"  type="radio" name="quiz26" class="quiz"> Bound</li>
                <li><input value="incorrect" type="radio" name="quiz26" class="quiz"> Free</li>
                <li><input value="incorrect" type="radio" name="quiz26" class="quiz"> Neither</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz26Correct">Correct!</p>
                <p class="incorrect" id="quiz26incorrect">Incorrect. Please try again.</p>
            </div>
            <p><code>contract x(y) = { 0 }</code></p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz27" class="quiz"> Bound</li>
                <li><input value="correct"  type="radio" name="quiz27" class="quiz"> Free</li>
                <li><input value="incorrect" type="radio" name="quiz27" class="quiz"> Neither</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz27Correct">Correct!</p>
                <p class="incorrect" id="quiz27incorrect">Incorrect. Please try again.</p>
            </div>
            <p><code>contract y(x) = { 0 }</code></p>
            <ul class="quiz">
                <li><input value="correct"  type="radio" name="quiz28" class="quiz"> Bound</li>
                <li><input value="incorrect" type="radio"  name="quiz28" class="quiz"> Free</li>
                <li><input value="incorrect" type="radio"  name="quiz28" class="quiz"> Neither</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz28Correct">Correct!</p>
                <p class="incorrect" id="quiz28incorrect">Incorrect. Please try again.</p>
            </div>
            <p><code>for (y &amp;lt;- @&quot;x&quot;){0}</code></p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio"  name="quiz29" class="quiz"> Bound</li>
                <li><input value="incorrect" type="radio" name="quiz29" class="quiz"> Free</li>
                <li><input value="correct"  type="radio" name="quiz29" class="quiz"> Neither</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz29Correct">Correct!</p>
                <p class="incorrect" id="quiz29incorrect">Incorrect. Please try again.</p>
            </div>
            <h2 id="the-new-operator">The <code>new</code> Operator</h2>
            <p><code>for</code> and <code>contract</code> are perfect for binding names inside of continuations. But what if we want to create a bound name to send messages on? For example, our pizza shop would prefer not to have its orders intercepted. We solve this with the <code>new</code> operator.</p>
            <pre class="rholang-file">new pizzaShop, stdout(`rho:io:stdout`) in {

  // Same contract as before
  contract pizzaShop(order) = {
    stdout!("Order Received.")
  }
  |
  // Known customers can order because pizzaShop is bound here.
  pizzaShop!("Extra bacon please")
  |
  pizzaShop!("Hawaiian Pizza to go")
}

// But we can't order from here, because pizzaShop doesn't exist
</pre>
            <p>First notice that <code>pizzaShop</code> is a name even though it doesn&#39;t start with <code>@</code>. That&#39;s because the <code>new</code> operator created it as a name directly rather than by quoting some written-down process. Whenever you create a <code>new</code> name, it is always a bound name.</p>
            <p>Second, notice that while this technique does prevent other pizza shops from consuming orders, it also prevents new customers from ordering. We&#39;ll solve this problem in the lesson on bundles.</p>
            <p>What happens when you try to order a pizza fron outside of the <code>new</code> restriction.</p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz30" class="quiz"> The order works fine</li>
                <li><input value="incorrect" type="radio" name="quiz30" class="quiz"> The order works but takes much longer</li>
                <li><input value="correct"  type="radio" name="quiz30" class="quiz"> Error about top-level free variables</li>
                <li><input value="incorrect" type="radio" name="quiz30" class="quiz"> The code runs, but no order is received</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz30Correct">Correct!</p>
                <p class="incorrect" id="quiz30incorrect">Incorrect. Please try again.</p>
            </div>
            <p>We learned that all names quote processes. So what process does the <code>pizzaShop</code> name quote? Try printing the process to <code>stdout</code> to see</p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz31" class="quiz"> It quotes &quot;pizzaShop&quot;</li>
                <li><input value="incorrect" type="radio" name="quiz31" class="quiz"> It doesn&#39;t quote anything</li>
                <li><input value="correct"  type="radio" name="quiz31" class="quiz"> &quot;Some Unforgeable hex code&quot;</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz31Correct">Correct!</p>
                <p class="incorrect" id="quiz31incorrect">Incorrect. Please try again.</p>
            </div>
            <h2 id="private-vs-unforgeable">Private vs Unforgeable</h2>
            <p class="imgWrapper"><img src="/assets/eavesdropping.png" alt="Although the messages can no longer be stolen, they can still be eavesdropped on. You&#39;ve been warned."></p>
            <p><code>new</code> is known as the restriction operator because it restricts use of the bound names that it creates to within it curly braces or &quot;lexical scope&quot;. Within the world of the rholang these new names really are only visible within the correct scope, but remember that human programmers can look in to that world from the outside. That is especially true when working in a blockchain context.</p>
            <p>So while a competing pizza shop can no longer <em>consume</em> pizza orders intended for our shop, they can still read the orders with a block explorer. Occasionally programmers call <code>new</code> names &quot;private&quot;, but a better term is &quot;unforgeable&quot;, which explains the answer to the previous question.</p>
            <p>We&#39;ve previously used <code>new</code> to prevent tuplespace pollution. Why did using unforgeable names prevent us from having to clear the tuplespace after each contract run?</p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz32" class="quiz"> Because <code>new</code> makes free names</li>
                <li><input value="correct"  type="radio" name="quiz32" class="quiz"> Because <code>new</code> creates unforgeable names that can&#39;t be accessed by outside code</li>
                <li><input value="incorrect" type="radio" name="quiz32" class="quiz"> Because <code>new</code> automatically clears the tuplespace</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz32Correct">Correct!</p>
                <p class="incorrect" id="quiz32incorrect">Incorrect. Please try again.</p>
            </div>
            <h2 id="acknowledgement-channels">Acknowledgement Channels</h2>
            <p class="imgWrapper"><img src="/assets/roger.png" alt="We acknowledge communications all the time in conversations"></p>
            <p>One common use of unforgeable names is &quot;acknowledgement channels&quot;, usually called &quot;ack&quot; channels for short. Instead of confirming orders by printing to the screen and disturbing <em>everyone</em>, the pizza shop should really just let the <em>customer</em> know that the order has been placed.</p>
            <p>To do that the pizza shop needs to know how to contact the customer. So the customer should supply an acknowledgement channel to be called back on. Traditionally such a channel is named <code>ack</code>.</p>
            <pre class="rholang-file">new pizzaShop in {

  // Now we take an order and an ack channel
  contract pizzaShop(order, ack) = {
    // Instead of acknowledging via stdout, we use ack
    ack!("Order Received.")
  }
  |
  // Known customers can order because pizzaShop is bound here.
  pizzaShop!("Extra bacon please", "alice")
  |
  pizzaShop!("Hawaiian Pizza to go", "bob")
}
</pre>
            <p>Why don&#39;t the acknowledgements in the previous example show up on the screen?</p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz33" class="quiz"> There is a bug in the code</li>
                <li><input value="incorrect" type="radio" name="quiz33" class="quiz"> The orders were not received correctly</li>
                <li><input value="correct"  type="radio" name="quiz33" class="quiz"> The confirmation was not sent to <code>stdout</code></li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz33Correct">Correct!</p>
                <p class="incorrect" id="quiz33incorrect">Incorrect. Please try again.</p>
            </div>
            <h3 id="exercise">Exercise</h3>
            <p>The previous example causes tuplespace pollution on the channels <code>@&quot;Alice&quot;</code> and <code>@&quot;Bob&quot;</code>. Fix it so that Alice and Bob both have unforgeable names.</p>
            <h2 id="sending-names-gives-permission">Sending Names Gives Permission</h2>
            <p>We just saw how the customer can give the shop an ack channel to receive order confirmation. It turns out we can do even better. With our previous code, anyone could contact the customer on the ack channel. That means anyone could send a forged ack making the customer think the order was placed when really it wasn&#39;t. Really Alice and Bob should keep their unforgeable names under tight control. Because giving someone that name gives them the capability to contact you.</p>
            <pre class="rholang-file">new pizzaShop in {

  // Take orders and acknowledge them
  contract pizzaShop(order, ack) = {
    ack!("Order Received.")
  }
  |
  // Order a pizza and send a private ack channel.
  new alice in {
    pizzaShop!("One medium veggie pizza", *alice)
  }
}
</pre>
            <p>The solution is to create a new unforgeable name, and give it to the pizza shop so that only they can call you back. Even though the pizza shop is <em>outside</em> of the <code>new alice</code>, it can still send on the channel because alice gave it the channels name. This is a wonderful way to delegate priveledges.</p>
            <p>In this example we trust the shop to only <em>send</em> on the ack channel, but notice that it could also receive if it wanted to. We&#39;ll learn how to give out only some of those permissions in the next lesson on bundles.</p>
            <p>Bob also wants to order a pizza and give a unforgeable ack channel. Where should he create his unforgeable channel?</p>
            <ul class="quiz">
                <li><input value="correct"  type="radio" name="quiz34" class="quiz"> On his own line, after the alice code</li>
                <li><input value="incorrect" type="radio" name="quiz34" class="quiz"> On the same line the Alice did</li>
                <li><input value="incorrect" type="radio" name="quiz34" class="quiz"> On the very first l ine of the program</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz34Correct">Correct!</p>
                <p class="incorrect" id="quiz34incorrect">Incorrect. Please try again.</p>
            </div>
            <h2 id="stdoutack-and-stderrack"><code>stdoutAck</code> and <code>stderrAck</code></h2>
            <p>Now that you understand ack channels, you should know about two other ways to print to the screen. They are channels called <code>stdoutAck</code> and <code>stderrAck</code>. They work just like their cousins from lesson 1, but they take an ack channel.</p>
            <pre class="rholang-file">new myAckChannel,
    stdout(`rho:io:stdout`),
    stdoutAck(`rho:io:stdoutAck`) in {
    
  stdoutAck!("Print some words.", *myAckChannel)
  |
  for (acknowledgement &lt;- myAckChannel) {
    stdout!("Received an acknowledgement.")
  }
}
</pre>
            <p>By the way, did you ever notice the handful of stuff that always starts in a fresh tuplespace? Four of those things are the built-in receives for the screen-printing channels. The others are for cryptography. We&#39;ll discuss them later.</p>
            <h3 id="exercise">Exercise</h3>
            <p><code>stdout!(&quot;1&quot;)|stdout!(&quot;2&quot;)|stdout!(&quot;3&quot;)</code> Notice that this program does not print the numbers in any particular order. The calls happen concurrently. Imagine we really need these lines to print in order. Modify the code to use ack channels and ensure that the numbers get printed in order.</p>
            <h3 id="exercise">Exercise</h3>
            <p>Predict how this program will run (what it outputs and how it reduces in the tuplespace). Then run it to test your prediction.
                <code>new myChan in {
  myChan!(&quot;Hi There&quot;)
}
|
for (msg &amp;lt;- myChan) {stdout!(*msg)}</code></p>
            <p>If your prediction for the previous exercise was wrong, modify the program so it actually does what you predicted it would.</p>
            <h2 id="quiz">Quiz</h2>
            <p>Which name is bound in <code>for(x &amp;lt;- y){0}</code></p>
            <ul class="quiz">
                <li><input value="correct"  type="radio" name="quiz35" class="quiz"> <code>x</code></li>
                <li><input value="incorrect" type="radio" name="quiz35" class="quiz"> <code>y</code></li>
                <li><input value="incorrect" type="radio" name="quiz35" class="quiz"> <code>0</code></li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz35Correct">Correct!</p>
                <p class="incorrect" id="quiz35incorrect">Incorrect. Please try again.</p>
            </div>
            <p>Which name is bound in <code>new x in {0}</code></p>
            <ul class="quiz">
                <li><input value="correct"  type="radio" name="quiz36" class="quiz"> <code>x</code></li>
                <li><input value="incorrect" type="radio" name="quiz36" class="quiz"> <code>y</code></li>
                <li><input value="incorrect" type="radio" name="quiz36" class="quiz"> <code>0</code></li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz36Correct">Correct!</p>
                <p class="incorrect" id="quiz36incorrect">Incorrect. Please try again.</p>
            </div>
            <p>If <code>pizzzaShop</code> is a name, then what is <code>@pizzaShop</code>?</p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz37" class="quiz"> A name</li>
                <li><input value="incorrect" type="radio" name="quiz37" class="quiz"> A process</li>
                <li><input value="correct"  type="radio" name="quiz37" class="quiz"> Invalid syntax</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz37Correct">Correct!</p>
                <p class="incorrect" id="quiz37incorrect">Incorrect. Please try again.</p>
            </div>
            <p>Why did the pizzaShopAck code send <code>&quot;bob&quot;</code> as an ack channel instead of <code>@&quot;bob&quot;</code>?</p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz38" class="quiz"> No reason; it&#39;s just a style choice.</li>
                <li><input value="correct"  type="radio" name="quiz38" class="quiz"> Because @&quot;bob&quot; is a name, but we have to send processes.</li>
                <li><input value="incorrect" type="radio" name="quiz38" class="quiz"> That&#39;s special syntax for ack channels.</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz38Correct">Correct!</p>
                <p class="incorrect" id="quiz38incorrect">Incorrect. Please try again.</p>
            </div>
        </div>

        <div class="card" id="bundlesSection">
            <h1 id="bundles">Bundles</h1>
            <h2 id="stolen-messages">Stolen Messages</h2>
            <p class="imgWrapper"><img src="/assets/Alice.png" alt="Alice&#39;s fans love her and want to send her lots of mail ."></p>
            <p>Alice is a rising celebrity who receives mail from her fans. They used to send mail directly to her on a public name.</p>
            <pre class="rholang-file">new stdout(`rho:io:stdout`) in {
  // Alice reads fan mail
  for (mail &lt;- @"alice") {
    stdout!("Alice received a fanmail")
  }
  |

  // Bob sends fan mail
  @"Alice"!("Dear Alice, you're #TheBest")
}
</pre>
            <p>But as she became more popular, her jealous competitor Eve began stealing her mail.</p>
            <h3 id="exercise">Exercise</h3>
            <p>Write the code for a competitor to steal the mail
                <!-- Answer in fanmailEve.rho -->
            </p>
            <p>The problem is that the competitors can listen on the same channel Alice can. So what she really needs is for her fans to have a &quot;write-only bundle&quot;</p>
            <pre class="rholang-file">// These channels are basically public names within
// the file like rho:pubkey:whatever

new alice, bob, eve, stdout(`rho:io:stdout`) in {

  // Alice gets a lot of fan mail, so she
  // creates a new write only bundle and publishes it.
  new aliceFanMail in {

    // Alice gives fanmail channel publically
    alice!!(bundle+ {*aliceFanMail})
    |

    // Alice also reads fan mail
    for (mail &lt;- aliceFanMail) {
      stdout!("Alice received a fanmail")
    }
  }
  |

  // When Bob wants to send fanmail he asks for the channel
  // and then sends
  for (aliceFanMail &lt;- alice) {
    aliceFanMail!("Dear Alice, you're #TheBest")
  }
  |

  // Eve tries to intercept a message, but cannot
  // because Alice's fanmail channel is write-only
  for (aliceFanMail &lt;- alice) {
    for (@stolenMail &lt;= aliceFanMail) {
      stdout!(["Eve stole a message: ", stolenMail])
    }
  }
}
</pre>
            <p>The <code>bundle+ {*aliceFanMail}</code> is a channel just like <code>aliceFanMail</code> except it can only be snet on, not received.</p>
            <h2 id="subscriptions">Subscriptions</h2>
            <p>The bundle solution above does prevent Ewritten onve from stealing mail, which is good. But in the blockchain context it also has the unfortunate side effect that Alice has to pay to send her fanmail address. Blockchain fees work a little like postage.</p>
            <p class="imgWrapper"><img src="/assets/returnEnvelope.png" alt="The sender includes a return envelope already posted to himself"></p>
            <h3 id="exercise">Exercise</h3>
            <p>Alice can save postage by making fans request the fanmail address from her. Then they will have to pay the transaction costs. A bit like sending a return envelope with a stamp already on it.</p>
            <p>Complete Alice&#39;s code so that she can get Bob the address he needs.</p>
            <p>Here&#39;s the answer:</p>
            <pre class="rholang-file">// These channels are basically public names within
// the file like rho:pubkey:whatever

new alice, bob, eve, stdout(`rho:io:stdout`) in {

  // Alice get a lot of fan mail, so she
  // creates a new write only bundle and publishes it.
  new aliceFanMail in {

    // Alice returns fanmail channel to any fan that asks
    for (return &lt;= alice) {
      return!(bundle+ {*aliceFanMail})
    }
    |

    // Alice also reads fan mail
    for (mail &lt;- aliceFanMail) {
      stdout!("Alice received a fanmail")
    }
  }
  |

  // When Bob wants to send fanmail he asks for the channel
  // and then sends
  new return in {
    alice!(*return) |
    for (aliceFanMail &lt;- return) {
      aliceFanMail!("Dear Alice, you're #TheBest")
    }
  }
  |

  // Eve tries to intercept a message, but cannot
  // because Alice's channel is write-only
  new return in {
    alice!(*return) |
    for (aliceFanMail &lt;- return) {
      for (@stolenMail &lt;= aliceFanMail) {
        stdout!(["Eve stole a message: ", stolenMail])
      }
    }
  }
}
</pre>
            <p>Astute readers will notice that Eve can now just intercept messages asking for the fanmail address. Good observation. As a bonus exercise, you could write Eve&#39;s new code. (hint: it&#39;s the same as the old code). The solution to this problem involves public key cryptography and the registry. We&#39;ll learn about that in unit 4.</p>
            <h3 id="exercise">Exercise</h3>
            <p>Our pizza shop back in lesson 2 had a similar problem to Alice. Rework that code so they can easily take on new customers.</p>
            <h2 id="jackpot">Jackpot</h2>
            <p class="imgWrapper"><img src="/assets/jackpot.png" alt="A single &quot;thrower&quot; throws a ball for one of many catchers to catch"></p>
            <p>I used to play a game called jackpot as a kid. One player would throw the ball and yell a number. The other players would all try to catch the ball and whoever caught it would receive that number of points.</p>
            <p>Playing jackpot is just the opposite of sending fanmail. Before there were many fans all sending to one celebrity. Now there is one thrower, sending to one of many recipients</p>
            <pre class="rholang-file">new throw, stdout(`rho:io:stdout`) in {
  // Throw the ball worth five points
  throw!(5)
  |

  // Throw the ball several more times
  throw!(4) |
  throw!(2) |
  throw!(6) |

  // Bill and Paige both try to catch
  for (points &lt;= throw){
    stdout!("Bill caught it")
  }
  |
  for (points &lt;= throw){
    stdout!("Paige caught it")
  }
}
</pre>
            <p>Who will catch the ball in the jackpot code?</p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz39" class="quiz"> Bill because his catch code is first.</li>
                <li><input value="incorrect" type="radio" name="quiz39" class="quiz"> Bill because his catch code is closest to the throw code.</li>
                <li><input value="incorrect" type="radio" name="quiz39" class="quiz"> Paige because her catch code is last.</li>
                <li><input value="correct"  type="radio" name="quiz39" class="quiz"> We don&#39;t know; it is nondeterminate.</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz39Correct">Correct!</p>
                <p class="incorrect" id="quiz39incorrect">Incorrect. Please try again.</p>
            </div>
            <h3 id="exercise">Exercise</h3>
            <p>Exercise: Use stdoutAck to display how many points each person actually gets when they catch the ball.</p>
            <!-- solution in jackpotNicePrinting.rho -->

            <p>Most programming languages will allow you to join or &quot;concatenate&quot; two strings together, and rholang is no exception. We can <code>stdout!(&quot;Hello &quot; ++ &quot;world&quot;)</code>, but we can&#39;t concatenate a string with an int. That&#39;s why we had to use that <code>stdoutAck</code> trick. Another option is to print a list <code>stdout!([&quot;Bill caught it. Points earned: &quot;, *points])</code>. We&#39;ll go into more detail about both techniques in future lessons.</p>
            <p>How is this game in rholang different than the real game where one ball is throw repeatedly?</p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz40" class="quiz"> It is a very accurate simulation</li>
                <li><input value="correct"  type="radio" name="quiz40" class="quiz"> In rholang all balls are thrown at once and caught in any order</li>
                <li><input value="incorrect" type="radio" name="quiz40" class="quiz"> In rholang the balls are caught in the reverse order from what they are thrown.</li>
                <li><input value="incorrect" type="radio" name="quiz40" class="quiz"> In rholang Bill makes all his catches, then Paige makes all her catches.</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz40Correct">Correct!</p>
                <p class="incorrect" id="quiz40incorrect">Incorrect. Please try again.</p>
            </div>
            <h2 id="imposter-throws">Imposter throws</h2>
            <p>Notice that anyone can come along and mess up this game by throwing fake balls. This is just the opposite of Eve coming along and stealing Alice&#39;s fanmail.</p>
            <p>What code would Eve have to par in to throw an imposter ball worth 100 points?</p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz41" class="quiz"> for (imposter &lt;- throw){imposter!(100)}</li>
                <li><input value="correct"  type="radio" name="quiz41" class="quiz"> throw!(100)</li>
                <li><input value="incorrect" type="radio" name="quiz41" class="quiz"> @&quot;throw&quot;!(&quot;100&quot;)</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz41Correct">Correct!</p>
                <p class="incorrect" id="quiz41incorrect">Incorrect. Please try again.</p>
            </div>
            <p>We solve this problem by making sure that the public can only read from the throw channel, but not write to it.</p>
            <pre class="rholang-file">new gameCh, stdout(`rho:io:stdout`) in {
  new throw in {

    //Give out read-only access
    gameCh!!(bundle- {*throw})
    |
    // Now actually make all the throws
    throw!(4) |
    throw!(2) |
    throw!(6)
  }
  |
  // Bill and Paige join the game
  for (throw &lt;- gameCh){
    for (points &lt;= throw){
      stdout!(["Bill caught it. Points: ", *points])
    }
  }
  |
  // Eve tries to throw a fake, but can't
  for (throw &lt;- gameCh){
    throw!(100)
  }
}
</pre>
            <p>Like before, this code requires the game host to pay for everyone who get&#39;s the bundle from him. It could be refactored so players have to subscribe to the game like we did with Alice and her fan mail.</p>
            <h2 id="public-key-crypto">Public Key Crypto</h2>
            <p class="imgWrapper"><img src="/assets/privateNames.png" alt="This bundle is sealed within the blockchain world, but totaly openable to anyone outside. Remember that just because data is off limits within the blockchain, doesn&#39;t mean it&#39;s truly private."></p>
            <p>In some ways, read-only bundles duplicate the signing features of <a href="https://en.wikipedia.org/wiki/Public-key_cryptography">public-key cryptography</a>. The jackpot catchers here are sure that the balls came from the thrower because only he can send on the throw channel, which is a lot like cryptographic signing.</p>
            <p>In some ways write-only bundles duplicate the encryption features of public-key cryptography. Only Alice can receive messages sent on her fan mail channel. One <strong>very important difference</strong> is that the messages sent here are 100% visible from outside the blockchain! So while write-only bundles are an effective way to communicate unforgeable names, they are not a good way to plot a heist, or evade government surveillance. <strong>Be Careful!</strong></p>
            <h2 id="more-bundles">More Bundles</h2>
            <p>In addition to read- and write-only bundles, there are two other types. The other bundle types are less common, but still useful. We&#39;ll explore them as the need arises, but I&#39;ll summarize them briefly here.</p>
            <table>
                <thead>
                    <tr>
                        <th>Syntax</th>
                        <th>Can Read</th>
                        <th>Can Write</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>bundle- {proc}</code></td>
                        <td>YES</td>
                        <td>NO</td>
                    </tr>
                    <tr>
                        <td><code>bundle+ {proc}</code></td>
                        <td>NO</td>
                        <td>YES</td>
                    </tr>
                    <tr>
                        <td><code>bundle {proc}</code></td>
                        <td>NO</td>
                        <td>NO</td>
                    </tr>
                    <tr>
                        <td><code>bundle {proc}</code></td>
                        <td>YES</td>
                        <td>YES</td>
                    </tr>
                </tbody>
            </table>

        </div>

        <div class="card" id="stateChannelsSection">
            <h1 id="state-channels">State Channels</h1>
            <h2 id="holding-on-to-data">Holding on to data</h2>
            <p class="imgWrapper"><img src="/assets/variables.png" alt="Variables are so 2015. It&#39;s all about state channels now."></p>
            <p>By now you&#39;re good at sending data to the tuplespace, and receiving data from the tuplespace. But whenever you&#39;re computing, you occasionally need to set data aside to be used later. Almost every programming language has a concept of variables.</p>
            <p>Another way in which rholang is unique is that it doesn&#39;t have traditional variables. Instead, we can just use the tuplespace to store our data. Whenever you want to set something aside for later, just send it on some channel and receive it back later. Channels that are used in this way are called &quot;state channels&quot;, and often have <code>Ch</code> at the end of their name</p>
            <pre class="rholang-file">new boxCh in {
  // To save data we just put it in the box
  boxCh!(42)
  |

  // Then to get data back out
  for (data &lt;- boxCh) {
    // Do whatever you want with the data here.
    @"somePublicChannel"!(*data)
  }
}
</pre>
            <p>What data gets sent to <code>@somePublicChannel</code>?</p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz42" class="quiz"> 0</li>
                <li><input value="incorrect" type="radio" name="quiz42" class="quiz"> box</li>
                <li><input value="correct"  type="radio" name="quiz42" class="quiz"> 42</li>
                <li><input value="incorrect" type="radio" name="quiz42" class="quiz"> It is empty</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz42Correct">Correct!</p>
                <p class="incorrect" id="quiz42incorrect">Incorrect. Please try again.</p>
            </div>
            <p>What data is left in the <code>boxCh</code> state channel?</p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz43" class="quiz"> 0</li>
                <li><input value="incorrect" type="radio" name="quiz43" class="quiz"> @&quot;somePublicBox&quot;</li>
                <li><input value="incorrect" type="radio" name="quiz43" class="quiz"> 42</li>
                <li><input value="correct"  type="radio" name="quiz43" class="quiz"> It is empty</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz43Correct">Correct!</p>
                <p class="incorrect" id="quiz43incorrect">Incorrect. Please try again.</p>
            </div>
            <h2 id="persisting-data">Persisting Data</h2>
            <p>If we were to check the box again, we would not get a result. Because once we receive the message, it gets consumed from the tuplespace. We briefly discussed the solution back in our lesson on persistent sends and peeks.</p>
            <pre class="rholang-file">new boxCh in {
  // To save data we just put it in the box
  boxCh!(42)
  |

  // To check the value without consuming it
  for (data &lt;- boxCh) {
    // We send a copy back to the box
    boxCh!(*data)
    |
    // The do whatever with it
    @"somePublicChannel"!(*data)
  }
}
</pre>
            <p>What data gets sent to <code>@somePublicChannel</code>?</p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz44" class="quiz"> 0</li>
                <li><input value="incorrect" type="radio" name="quiz44" class="quiz"> box</li>
                <li><input value="correct"  type="radio" name="quiz44" class="quiz"> 42</li>
                <li><input value="incorrect" type="radio" name="quiz44" class="quiz"> It is empty</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz44Correct">Correct!</p>
                <p class="incorrect" id="quiz44incorrect">Incorrect. Please try again.</p>
            </div>
            <p>What data is left in the <code>boxCh</code> state channel?</p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz45" class="quiz"> 0</li>
                <li><input value="incorrect" type="radio" name="quiz45" class="quiz"> @&quot;somePublicBox&quot;</li>
                <li><input value="correct"  type="radio" name="quiz45" class="quiz"> 42</li>
                <li><input value="incorrect" type="radio" name="quiz45" class="quiz"> It is empty</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz45Correct">Correct!</p>
                <p class="incorrect" id="quiz45incorrect">Incorrect. Please try again.</p>
            </div>
            <h2 id="patience-game-revisited">Patience Game Revisited</h2>
            <p>A few lessons back we discussed the patience game, where each player hopes to be the last one to send a message to the contract. We had some problems back then because we couldn&#39;t guarantee that a result of the game would ever be output.</p>
            <p>Take a minute to remind yourself of the problem we had. With a state channel, we can solve this problem properly.</p>
            <pre class="rholang-file">new P1, P2, stdout(`rho:io:stdout`) in {

  // active gets its own scope so players can't change its value.
  new active in {
    active!(true)
    |
    for(_ &lt;- active; _ &lt;- P1) {
      for( _ &lt;- P2) {
        stdout!("P2 Wins")
      }
    }
    |
    for(_ &lt;- active; _ &lt;- P2) {
      for (_ &lt;- P1) {
        stdout!("P1 Wins")
      }
    }
  }
  |
  P1!(0)
  |
  P2!(0)
}
</pre>
            <p>How does the above code avoid the problem of each block getting called once?</p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz46" class="quiz"> By forcing player one to use the top block</li>
                <li><input value="correct"  type="radio" name="quiz46" class="quiz"> Because after the first call <code>activeCh</code> is empty</li>
                <li><input value="incorrect" type="radio" name="quiz46" class="quiz"> Because state channel make things sequential</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz46Correct">Correct!</p>
                <p class="incorrect" id="quiz46incorrect">Incorrect. Please try again.</p>
            </div>
            <h2 id="objects-and-methods">Objects and Methods</h2>
            <p class="imgWrapper"><img src="/assets/clickCounter.png" alt="This click-counter can be incremented and reset"></p>
            <p>In &quot;Object Oriented Programming&quot; languages such as java, we can model real-world objects by encapsulating some data along with methods that use or change the data. The same thing is possible in rholang.</p>
            <p>In this example, we&#39;ll create an object that represents a basic click counter. The ingredients are:</p>
            <ul>
                <li>State Channels: currentCount</li>
                <li>Methods: increase, reset</li>
            </ul>
            <pre class="rholang-file">new currentCount, increase, reset, stdout(`rho:io:stdout`) in {

  // Start the counter at zero
  currentCount!(0) |

  // Method to increase counter (returns the old value)
  contract increase(ack) = {
    for (old &lt;- currentCount) {
      currentCount!(*old + 1) |
      ack!(*old)
    }
  }
  |

  // Method to reset the counter (returns the old value)
  contract reset(ack) = {
    for(old &lt;- currentCount){
      currentCount!(0) |
      ack!(*old)
    }
  }
  |

  // Demo using the counter
  // This part gets deeply nested because it is sequential
  new ack in {

    // Increase the counter three times
    increase!(*ack) |
    increase!(*ack) |
    increase!(*ack) |

    // And check it's value afterward
    for(_ &lt;- ack; count &lt;- currentCount) {
      stdout!(*count)
    }
  }
}
</pre>
            <h3 id="exercises">Exercises</h3>
            <p>It is inconvenient to manually replace the counter value each time I check it. Instead we should have a method for that.</p>
            <!-- answer in checkMethod.rho -->


            <h3 id="exercise">Exercise</h3>
            <p>Now that it&#39;s easier and safer to check the counter, let&#39;s write some better tests that actually check all the methods.</p>
            <!-- answer in counterTests.rho -->

            <h2 id="factories">Factories</h2>
            <p>If you&#39;ve programmed in other languages like java you may be familiar with constructors. If you haven&#39;t programmed in in java, that&#39;s great, because Rholang uses factories to make new objects rather than constructors.</p>
            <p>The counter is a useful construct in rholang, and you&#39;ll likely find that you use it in your projects. The problem is that many projects may want to use counters, and having just one is insufficient. So the solution is to make a factory contract that makes counters. When the factory contract is called, it sends back a brand new counter.</p>
            <pre class="rholang-file">new counterFactory, stdout(`rho:io:stdout`) in {
  contract counterFactory(increase, reset) = {
    new currentCount in {
      // Start the counter at zero
      currentCount!(0) |

      // Method to increase counter (returns the old value)
      contract increase(ack) = {
        for (old &lt;- currentCount) {
          currentCount!(*old + 1) |
          ack!(*old)
        }
      }
      |

      // Method to reset the counter (returns the old value)
      contract reset(ack) = {
        for(old &lt;- currentCount){
          currentCount!(0) |
          ack!(*old)
        }
      }
    }
  }
  |

  new ack, myIncrease, myReset in {
    // Demo using the counter here
    0
  }
}
</pre>
            <p>How would a user call the factory to get a new counter?</p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz47" class="quiz"> <code>counterFactory!(*ack)</code></li>
                <li><input value="incorrect" type="radio" name="quiz47" class="quiz"> <code>counterFactory!(0, *ack)</code></li>
                <li><input value="incorrect" type="radio" name="quiz47" class="quiz"> <code>@&quot;counterFactory&quot;()</code></li>
                <li><input value="correct"  type="radio" name="quiz47" class="quiz"> <code>counterFactory!(myIncrease, myReset)</code></li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz47Correct">Correct!</p>
                <p class="incorrect" id="quiz47incorrect">Incorrect. Please try again.</p>
            </div>
            <p>How would a user reset their counter after creating as indicated above.</p>
            <ul class="quiz">
                <li><input value="incorrect" type="radio" name="quiz48" class="quiz"> <code>myIncrease!(*ack)</code></li>
                <li><input value="correct"  type="radio" name="quiz48" class="quiz"> <code>myReset!(*ack)</code></li>
                <li><input value="incorrect" type="radio" name="quiz48" class="quiz"> <code>counterFactory!(myReset, *ack)</code></li>
                <li><input value="incorrect" type="radio" name="quiz48" class="quiz"> <code>counterFactory!(myReset)</code></li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz48Correct">Correct!</p>
                <p class="incorrect" id="quiz48incorrect">Incorrect. Please try again.</p>
            </div>
            <h2 id="method-dispatching">Method Dispatching</h2>
            <p>There are two primary techniques for making methods available. The first option I call &quot;separation of powers&quot; because each method listens on its own dedicated channel.</p>
            <p>Another option is the &quot;control panel&quot; technique where there is a single unforgeable name called the control panel and all the methods are built on it.</p>
            <pre class="inline-code">// Separation of Powers
contract factory(method1, method2) = {
  contract method1(ack) = { ... }
  contract method2(ack) = { ... }
}

// Control Panel
contract factory(cPanel) = {
  contract @[cPanel, "method1"](ack) = { ... }
  contract @[cPanel, "method2"](ack) = { ... }
}</pre>
            <p>Which technique did the counter example use to dispatch methods?</p>
            <ul class="quiz">
                <li><input value="correct"  type="radio" name="quiz49" class="quiz"> Separation of Powers</li>
                <li><input value="incorrect" type="radio" name="quiz49" class="quiz"> Control Panel</li>
            </ul>
            <div class="quizResponse">
                <p class="correct" id="quiz49Correct">Correct!</p>
                <p class="incorrect" id="quiz49incorrect">Incorrect. Please try again.</p>
            </div>
            <h3 id="exercise">Exercise</h3>
            <p>Convert the counter example to use the other method dispatching technique. You should convert the tests too.</p>

        </div>


    </div>


</div>
